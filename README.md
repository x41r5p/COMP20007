Assignment 1 2025<br>General<br>General<br>You must read fully and carefully the assignment specification and instructions.<br>Course: COMP20007 Design of Algorithms @ Semester 1, 2025<br>Deadline Submission: Monday, 7th April @ 11:59 pm<br>Course Weight: 10%<br>Assignment type: individual<br>ILOs covered: 2, 3, 4<br>Submission method: via ED<br>Purpose<br>The purpose of this assignment is for you to:<br>Design efficient algorithms in pseudocode.<br>Improve your proficiency in C programming and your dexterity with dynamic memory<br>allocation.<br>Demonstrate understanding of a representing problems as graphs and implementing a set of<br>algorithms.<br>Birds of a feather<br>Why should we group species?<br>In the field of genetics we are often interested in grouping similar species together to understand how<br>animals have evolved over time. Understanding evolution allows us to make more informed<br>decisions in conservation efforts, but may also lead to the discovery of new medicines, as similar<br>species produce similar responses to external changes. One possible method of grouping species<br>together is by how similar they are, which historically has been based on how similar their physical<br>features are. Some examples of Australian birds are shown below:<br>Left: Wompoo Fruit-Dove, Middle: Azure Kingfisher, Right: Pale-Yellow Robin<br>Now, one possible grouping of these three birds is to have them grouped by size - we would expect<br>small birds like the Pale-Yellow Robin or Azure Kingfisher to have more in common than the larger<br>Wompoo Fruit-Dove. Of course, we can also group them based on more features, using an<br>algorithmic approach. Examples of such algorithms are Blake's averages and Cynthia's midpoints.<br>Other Applications<br>Grouping methods have numerous real-world applications, which include:<br>Disease Management: Tracking information about the spread of sickness and grouping<br>together individuals with similar health problems can help us to identify high-risk population<br>areas and take preventative steps to save lives.<br>Resource Allocation: Identifying groups of animals with high/low resource usage can help<br>better distribute resources and help conservation efforts.<br>Content Personalisation: Grouping together users with similar tastes can help individuals<br>access the content and information they want more often.<br>Group Computation Algorithms<br>Blake's Averages<br>Initialization:<br>Start by selecting the first c birds as the centres of the c groupings desired.<br>Assign all other birds to their nearest group centre.<br>Calculate Averages:<br>For each group, find the average of all the features.<br>For each group, find the bird that is closest to this average.<br>Re-assign all birds to the new closest groups.<br>Termination:<br>Repeat the main loop until the group centres stop changing, or we exceed a maximum<br>number of iterations.<br>Once the centres stop changing, the algorithm terminates.<br>Output:<br>The output of the algorithm is the list of birds with their features and group<br>memberships, ordered alphabetically.<br>The time complexity of the Blake's Averages algorithm is where is the number<br>of data points, is the number of features per point, is the desired number of clusters, and is the<br>number of iterations. As should not vary that much and effectively be constant, we will have a<br>complexity of roughly .<br>O(n    d    c    i) n<br>d c i<br>i<br>O(n    c    d)<br>Pseudocode<br>BlakeAverages(birds, numBirds, numGroups):<br>// inputs:<br>// birds, a list of birds.<br>// numBirds, the number of birds.<br>// numGroups, the number of groups.<br>// Initialise the groups by, for the first c birds, assigning bird i to group i.<br>birds <- initialiseBirds()<br>// Assign each bird to the nearest group centre<br>birds <- assignGroups()<br>repeat:<br>// record the current group centres<br>previousCentres <- currentCentres<br>// calculate the mean of each group and find the birds which act as the new group centres<br>currentCentres <- calculateMeans()<br>// Assign each bird to the nearest group centre<br>birds <- assignGroups()<br>until previousCentres == currentCentres or we exceed the maximum iteration count<br>// all done, so return grouping<br>return birds<br>Cynthia's Midpoints<br>Initialization:<br>Start by selecting the first c birds as the centres of the c groupings desired.<br>Assign all other birds to their nearest group centre.<br>Calculate Midpoints:<br>For each group, find the median of the numeric features.<br>For each group, find the mode of the categorical features.<br>For each group, find the bird that is closest to this combination of midpoints.<br>Re-assign all birds to the new closest groups.<br>Termination:<br>Repeat the main loop until the group centres stop changing, or we exceed a maximum<br>number of iterations.<br>Once the centres stop changing, the algorithm terminates.<br>Output:<br>The output of the algorithm is the list of birds with their features and group<br>memberships, ordered alphabetically.<br>As we will sort the elements every time we need to find a median, the time complexity of the<br>Cynthia's Midpoints algorithm is ,<br>where is the number of data points, is the number of features per point, is the desired number<br>of clusters, and is the number of iterations. As should not vary that much and effectively be<br>constant, we will have a complexity of roughly .<br>Pseudocode<br>CynthiaMidpoints(birds, numBirds, numGroups):<br>// inputs:<br>// birds, a list of birds.<br>// numBirds, the number of birds.<br>// numGroups, the number of groups.<br>// Initialise the groups by, for the first c birds, assigning bird i to group i.<br>birds <- initialiseBirds()<br>// Assign each bird to the nearest group centre<br>birds <- assignGroups()<br>repeat:<br>// record the current group centres<br>previousCentres <- currentCentres<br>// calculate the midpoints of each group and find the birds which act as the new group cent<br>// For each group<br>// Find the most common colour<br>// Find the median weight<br>// Find the median bodyLength<br>currentCentres <- calculateMeds()<br>// Assign each bird to the nearest group centre<br>birds <- assignGroups()<br>until previousCentres == currentCentres or we exceed the maximum iteration count<br>// all done, so return grouping<br>return birds<br>Notes<br>Your main function should look like the following pseudocode:<br>main():<br>// Initialise an empty list to store birds, and group centres<br>birds <- empty list<br>// Read in the list of birds and number of groups<br>birds, numBirds, numGroups <- readBirds()<br>if no birds input:<br>print "No birds input."<br>return 1<br>if number of birds < number of groups:<br>print "Invalid Data."<br>return 1<br>// using the method read from argv:<br>if method == "B":<br>birds <- BlakeAverages()<br>else if method == "C":<br>birds <- CynthiaMidpoints()<br>else:<br>print "Invalid method."<br>// Print out the list of birds and their group assignments<br>print(birds)<br>// free all of the data<br>free(birds)<br>The process of grouping can be visualized in two dimensions, and may look like the following.<br>In the image, different colours represent the different groups.<br>Example<br>An example of input and output is provided on the Part 1 Skeleton Slide.<br>Task 1: Group Computation<br>Part A<br>Implement the Blake's Averages and Cynthia's Midpoints algorithms to compute a grouping of<br>birds, as described in the previous slide.<br>Requirements<br>Code: Your program should implement the required pseudocode mentioned in previous slides,<br>as well as a couple helper functions listed in the skeleton code.<br>Input Format: The input will be a text file where the first line indicates the total number of<br>Australian birds, and the total number of groups. Subsequent lines represent birds with their<br>name, colour, weight (grams) and body length (cm) separated by a space (e.g., Red?backed_Fairywren Black 5 10 ). All the birds are sorted in alphabetical order by name using<br>Unix sorting order.<br>Output Format: Your program should output all birds, their features and associated groupings<br>in alphabetical order. For Blake's Averages, this means keeping it in the original ordering (Unix<br>sorting rules), and in Cynthia's midpoints it will be alphabetically sorted using strcmp sorting<br>rules. This should be done by traversing your array of birds and printing out each bird. This<br>should be output to the console (stdout).<br>Part B<br>Evaluate both algorithms through experimental analysis by quantifying the average total basic<br>operations per iteration of the main loop (calculated by dividing the number of operations in the<br>main loop by the number of iterations taken) of the two algorithms (Blake's Averages and Cynthia's<br>Midpoints) across various input scales and configurations. Use all of the valid input sets provided.<br>You may wish to generated more data, and you can do so with the provided files in the analysis<br>folder.<br>You must decide what to define as the basic operation for each algorithm, but remember to only<br>count the basic operations in the main while loop.<br>Reporting: Write a report including a discussion on the choice of algorithm, the experimental<br>evaluation (including tables or graphs showing how the average number of basic operations varies<br>with the input parameters (n and d)), and conclusions drawn from the comparisons. Include any<br>assumptions or simplifications made in your implementations. In addition, discuss:<br>Possible improvements that can be made to the main loop of the algorithms, if any, to reduce<br>complexity.<br>Why you selected this basic operation.<br>Tip: The global variable numOps is provided to track the operation count. You may need to modify some of<br>the functions (such as the comparison functions) to increment the operation counter. By default, the<br>information relating to operation counts is printed to stderr.<br>Include your operation counting code as an appendix to the report.<br>Submission Guidelines<br>Submit your C source code files with appropriate comments explaining the algorithms and data<br>structures used.<br>Your report should be in PDF format, including your findings from the experimental evaluation<br>and any observations and theoretical improvements regarding the performance of the two<br>algorithms.<br>The report for Part 1B should be submitted as a PDF file named written_task_1B.pdf . The file<br>should be uploaded to the home directory of Part 1A, that is, the directory that contains your<br>program file birds.c .<br>Grading Criteria<br>Correctness of the implemented algorithms and adherence to the requirements.<br>Efficiency (time and space) and proper storage of birds.<br>Clarity of the report, including the depth of the experimental evaluation and the analysis of the<br>results.<br>Code readability, structure, and documentation.<br>Task 1 Skeleton<br>Example of Input:<br>10 3<br>Australasian_Swamphen Blue 1310 51<br>Australian_Bushturkey Black 2100 64.3<br>Australian_Darter Black 2600 86.5<br>Australian_King-Parrot Red 195 42<br>Australian_Logrunner Black 56 19<br>Australian_Magpie Black 350 85<br>Australian_Pelican White 6800 188<br>Australian_Rufous_Fantail Grey 10 18.5<br>Australian_White_Ibis White 1475 66.4<br>Australian_Wood_Duck Brown 955 46<br>Example of Output (for Blake's Averages):<br>Australasian_Swamphen Blue 1310.000000 51.000000 Group: 1<br>Australian_Bushturkey Black 2100.000000 64.300000 Group: 2<br>Australian_Darter Black 2600.000000 86.500000 Group: 2<br>Australian_King-Parrot Red 195.000000 42.000000 Group: 0<br>Australian_Logrunner Black 56.000000 19.000000 Group: 0<br>Australian_Magpie Black 350.000000 85.000000 Group: 0<br>Australian_Pelican White 6800.000000 188.000000 Group: 2<br>Australian_Rufous_Fantail Grey 10.000000 18.500000 Group: 0<br>Australian_White_Ibis White 1475.000000 66.400000 Group: 1<br>Australian_Wood_Duck Brown 955.000000 46.000000 Group: 1<br>Example of Output (for Cynthia's Midpoints):<br>Australasian_Swamphen Blue 1310.000000 51.000000 Group: 1<br>Australian_Bushturkey Black 2100.000000 64.300000 Group: 1<br>Australian_Darter Black 2600.000000 86.500000 Group: 1<br>Australian_King-Parrot Red 195.000000 42.000000 Group: 0<br>Australian_Logrunner Black 56.000000 19.000000 Group: 0<br>Australian_Magpie Black 350.000000 85.000000 Group: 0<br>Australian_Pelican White 6800.000000 188.000000 Group: 2<br>Australian_Rufous_Fantail Grey 10.000000 18.500000 Group: 0<br>Australian_White_Ibis White 1475.000000 66.400000 Group: 1<br>Australian_Wood_Duck Brown 955.000000 46.000000 Group: 0<br>Eels in the Kulin Nation<br>Short-finned eels are a fish which live in the freshwater systems around south-eastern Australia. To<br>the First Peoples of the Kulin Nation - the traditional custodians of the lands and waters surrounding<br>what is now Melbourne, or Naarm (which is the Boonwurrung/Woiwurrung name for Port Phillip) -<br>these eels were very important food sources. The Wurundjeri people of the Kulin Nation had seven<br>seasons rather than the Western four, and one of the seasons was dedicated to the short-finned eel<br>migration, this season is known as Iuk (https://inspiringvictoria.org.au/2020/08/13/seasons-in-the?sky/). During Iuk, the short-finned eels which live in the freshwater systems of the Kulin Nation<br>migrate out to the ocean to begin their long journey to the warm waters of the Coral Sea, some<br>3,000km away, to breed. However, before setting out for this extensive journey the eels must eat and<br>get fat to survive the long swim. Hence, the people of the Kulin Nation would make extensive fish<br>traps in the river systems to catch and eat the fattened eels during Iuk, which have been described as<br>having a buttery taste by a Yorta Yorta person.<br>Feeding and breeding eels<br>You are a fresh water eel in the river systems of the Kulin Nation. There are many rivers which<br>connect different lakes together, and eventually to the ocean.<br>Part A<br>You find that these river systems are difficult to navigate, and you wonder if you are running in<br>circles. Write an algorithm to tell if there are any paths in this river system which could form. a cycle,<br>i.e. leaving from one lake you could take a certain path of distinct rivers that reaches back to the<br>starting lake.<br>This algorithm should work for any set of lakes and rivers. There will be a certain number of lakes,<br>each with a uniqu代 写COMP20007、C/C++
程序e identifier lakeID    [0, numLakes). Each river will run from one lake to<br>another, but you may assume that rivers can be travelled in both directions.<br>The first line of input is the number of lakes, and number of rivers in the system respectively. The<br>subsequent lines will each represent a river, with the first value being the lakeID it flows from and the<br>second being the lakeID it flows to. The input will look like:<br>[num_lakes] [num_rivers]<br>[from_lakeID] [to_lakeID]<br>...<br>The output of the program should print "We're running in circles!" if there is a cycle found, and<br>"Smooth sailing" if not.<br>Part B<br>You are very hungry and have heard of some good feeding grounds further inland, but it is a long<br>way and you can't figure out what's the best way to go given all the different rivers and lakes. You<br>want to get there as fast as possible before the food is all eaten up. The amount of time taken to<br>traverse a river is equal to the river's length. Unfortunately, because of a strong current, it takes<br>twice as long to swim upstream as it does to swim downstream.<br>Write an algorithm that will find the shortest way to reach the feeding grounds from the ocean.<br>This algorithm should work for any set of lakes and rivers. As with Part 1, there will be a certain<br>number of lakes, each with a unique identifier lakeID    [0, numLakes). Each river will run from<br>one lake to another and have an associated length with it as well.<br>The first line of the input will contain the lakeID which you are starting from, followed by the lakeID<br>of the destination lake where the feeding grounds are. The second line contains the number of lakes<br>and number of rivers in the system. The subsequent lines each contain a river, with the lakeID of the<br>lake it flows from followed by the lakeID of the lake it flows into, and then the final value is the river's<br>length.<br>The input will look like:<br>[origin_lake] [destination_lake]<br>[num_lakes] [num_rivers]<br>[from_lakeID] [to_lakeID] [length_in_km]<br>...<br>The output of the program should print the total length of the shortest path to the feeding ground,<br>followed by the lakeIDs of the lakes traversed to reach it (i.e. by going from lake to lake through the<br>rivers).<br>The output should look like:<br>Total cost: [total_length]<br>Path: [origin_lakeID], [lakeID_1], [lakeID_2], ..., [destination_lakeID]<br>Part C<br>The breeding season (Iuk) is fast approaching, so you need to make your way back to the ocean and<br>onto the Coral Sea. However, you want to maximise the amount of fat you have by the time you<br>reach the ocean. Swimming down rivers costs energy (and burns fat), but in many cases, you need to<br>swim through some rivers and lakes anyway to get to the sea. Moreover, the lakes tend to have some<br>food in them, which can increase your fat supplies again. Assume that you only travel the rivers<br>downstream because you want to reach the sea as quickly as possible.<br>Propose an algorithm to find the best way to get back to the ocean, ensuring that, in total, you have<br>the maximum fat stores upon reaching the ocean. This algorithm should run in O((V +<br>E)log(V )). This algorithm may only work with certain sets of rivers and lakes, and it is up to you to<br>check whether the input will be solvable in this time complexity as part of your algorithm.<br>Write the pseudocode for this algorithm. You may assume the following:<br>The input graph is a directed weighted graph. Each edge (u, v, w) is represented as a single<br>element in the adjacency list for u.<br>There is a function Dijkstra(graph, origin, destination)    (cost, path) that returns the<br>cost and the path of the lowest-cost path from origin to destination.<br>As part of the input data, you have an array fatGain[0..numLakes ? 1] where fatGain[i]<br>stores the amount of fat (in some units) you always gain when you reach the lake with ID i.<br>When you swim downstream along a river of length w, you lose exactly w units of fat.<br>At the start of your journey back to the sea, you have K units of fat in your body. You will die<br>when the number of fat units in your body reaches 0.<br>You must justify your algorithm design choices in 300 words, including why certain sets of rivers and<br>lakes won't work with the algorithm.<br>Notes:<br>No marks will be awarded if your algorithm's time complexity is not O((V + E)log(V )), or if<br>your algorithm is incorrect for the problem.<br>The report for Part 2C should be submitted as a PDF file named written_task_2C.pdf . The file<br>should be uploaded to the home directory of Part 2B, the directory that contains your program<br>files dijkstra.c , graph.c , etc.<br>Task 2, Part A Skeleton<br>Implement a function, cycleCheck(graph_t *graph), which returns 1 if a cycle is found, and 0<br>otherwise.<br>The main driver functions have already been implemented.<br>The first line of input is the number of lakes, and number of rivers in the system respectively. The<br>subsequent lines will each represent a river, with the first value being the lakeID it flows from and the<br>second being the lakeID it flows to. The input will look like:<br>[num_lakes] [num_rivers]<br>[from_lakeID] [to_lakeID]<br>...<br>The output of the program should print "We're running in circles!" if there is a cycle found, and<br>"Smooth sailing" if not.<br>Input Data Sets<br>A number of input data files are provided in the subdirectory test_cases . Each file name starts with<br>the prefix t2a- . The data file t2a-0.txt represents a simplified version of some lakes and water<br>flows (like rivers, creeks, canals) between them for the area around Lakes Entrance in Victoria. It<br>should be noted that this area does not belong to the Kulin Nation (it actually belongs to the<br>Gunaikurnai people). The area was chosen here for illustrative purposes.<br>Also note that t2b-0.txt is the same as t2a-0.txt , but which additional data for using in Part B.<br>Task 2, Part B Skeleton<br>Write a function dijkstra(graph_t *graph, int origin, int dest, int *path) which computes<br>the shortest path from origin to dest and returns the cost of this path, and the path should be<br>written into the path argument. This function should return the SENTINEL value (-1) if there is no<br>path, and print out "No Path".<br>The input data will look like:<br>[origin_lake] [destination_lake]<br>[num_lakes] [num_rivers]<br>[from_lakeID] [to_lakeID] [length_in_km]<br>...<br>The output should look like:<br>Total cost: [total_length]<br>Path: [origin_lakeID], [lakeID_1], [lakeID_2], ..., [destination_lakeID]<br>Most scaffolding functions have been written for you, including I/O and a basic graph and priority<br>queue implementation. We recommend you use these, but you are welcome to write your own if you<br>wish, you must ensure that the output is in the same form. of the output the test cases give.<br>Task 2B Test Cases<br>1 Automatic Zoom<br>Academic Honesty<br>This is an individual assignment. The work must be your own work.<br>While you may discuss your program development, coding problems and experimentation with your<br>classmates, you must not share files, as doing this without proper attribution is considered<br>plagiarism.<br>If you have borrowed ideas or taken inspiration from code and you are in doubt about whether it is<br>plagiarism, provide a comment highlighting where you got that inspiration.<br>If you refer to published work in the discussion of your experiments, be sure to include a citation to<br>the publication or the web link.<br>  Borrowing   of someone else  s code without acknowledgment is plagiarism. Plagiarism is considered<br>a serious offense at the University of Melbourne. You should read the University code on Academic<br>integrity and details on plagiarism. Make sure you are not plagiarizing, intentionally or<br>unintentionally.<br>You are also advised that there will be a C programming component (on paper, not on a computer) in<br>the final examination. Students who do not program their own assignments will be at a disadvantage<br>for this part of the examination.<br>Late Policy<br>The late penalty is 20% of the available marks for that project for each working day (or part thereof)<br>overdue.<br>If you wish to apply for an extension, please review the FEIT Extensions and Special consideration<br>page on the subject LMS. Requests for extensions on medical grounds will need to be supported by a<br>medical certificate. Any request received less than 48 hours before the assessment date (or after the<br>date!) will generally not be accepted except in the most extreme circumstances. In general, extensions<br>will not be granted if the interruption covers less than 10% of the project duration. Remember that<br>departmental servers are often heavily loaded near project deadlines, and unexpected outages can<br>occur; these will not be considered as grounds for an extension.<br>Students who experience difficulties due to personal circumstances are encouraged to make use of<br>the appropriate University student support services, and to contact the lecturer, at the earliest<br>opportunity.<br>Finally, we are here to help! Frequently asked questions about the project will be answered on Ed.<br>Requirements: C Programming<br>The following implementation requirements must be adhered to:<br>You must write your implementation in the C programming language.<br>Your code should be easily extensible to multiple data structure instances. This means that the<br>functions for interacting with your data structures should take as arguments not only the values<br>required to perform. the operation required, but also a pointer to a particular data structure, e.g.<br>search(dictionary, value) .<br>Your implementation must read the input file once only.<br>Your program should store strings in a space-efficient manner. If you are using malloc() to<br>create the space for a string, remember to allow space for the final end of string character,    \0   <br>( NULL ).<br>Your approach should be reasonably time efficient.<br>Your solution should begin from the provided scaffold.<br>Hints:<br>? If you haven  t used make before, try it on simple programs first. If it doesn  t work, read the error messages<br>carefully. A common problem in compiling multifile executables is in the included header files. Note also that<br>the whitespace before the command is a tab, and not multiple spaces.<br>? It is not a good idea to code your program as a single file and then try to break it down into multiple files.<br>Start by using multiple files, with minimal content, and make sure they are communicating with each other<br>before starting more serious coding.<br>Programming Style<br>Below is a style. guide which assignments are evaluated against. For this subject, the 80 character<br>limit is a guideline rather than a rule    if your code exceeds this limit, you should consider whether<br>your code would be more readable if you instead rearranged it.<br>/** ***********************<br>* C Programming Style. for Engineering Computation<br>* Definitions and includes<br>* Definitions are in UPPER_CASE<br>* Includes go before definitions<br>* Space between includes, definitions and the main function.<br>* Use definitions for any constants in your program, do not just write them<br>* in.<br>*<br>* Tabs may be set to 4-spaces or 8-spaces, depending on your editor. The code<br>* Below is ``gnu'' style. If your editor has ``bsd'' it will follow the 8-space<br>* style. Both are very standard.<br>* We should not comment obvious things - write code that documents itself<br>Some automatic evaluations of your code style. may be performed where they are reliable. As<br>determining whether these style-related issues are occurring sometimes involves non-trivial (and<br>sometimes even undecidable) calculations, a simpler and more error-prone (but highly successful)<br>solution is used. You may need to add a comment to identify these cases, so check any failing test<br>outputs for instructions on how to resolve incorrectly flagged issues.<br>Mark Breakdown<br>There are a total of 10 marks given for this assignment.<br>Your C programs for Task 1 and 2 should be accurate, readable, and observe good C programming<br>structure, safety and style, including documentation. Safety refers to checking whether opening a file<br>returns something, whether mallocs do their job, etc. The documentation should explain all major<br>design decisions, and should be formatted so that it does not interfere with reading the code. As<br>much as possible, try to make your code self-documenting, by choosing descriptive variable names.<br>The remainder of the marks will be based on the correct functioning of your submission.<br>Note that marks related to the correctness of your code will be based on passing various tests. If your<br>program passes these tests without addressing the learning outcomes (e.g. if you fully hard-code<br>solutions or otherwise deliberately exploit the test cases), you may receive less marks than is<br>suggested but your code marks will otherwise be determined by test cases. For questions with both a<br>written component and a C code component, part of the mark will be given for the passing of test<br>cases, with the remainder from the correctness of the written answer.<br>Task 1 will be marked out of 4 marks, Task 2 will be marked out of 5 marks and C code quality will<br>comprise the final mark.<br>Additional Support<br>Your tutors will be available to help with your assignment during the scheduled workshop times.<br>Questions related to the assignment may be posted on the Ed discussion forum, using the folder tag<br>Assignments for new posts. You should feel free to answer other students questions if you are<br>confident of your skills.<br>A tutor will check the discussion forum regularly, and answer some questions, but be aware that for<br>some questions you will just need to use your judgment and document your thinking.<br>If you have questions about your code specifically which you feel would reveal too much of the<br>assignment, feel free to post a private question on the discussion forum.<br>Most students find Academic Skills' Research Report Guide extremely valuable in constructing a well<br>formed and sensible analysis that makes good use of relevant material taught so far in the subject.<br>Acknowledgements<br>ChatGPT was used to help generate some graphs for Task 2A.<br><br><br>加QQ：99515681  WX：codinghelp  Email: 99515681@qq.com
